name: Validate scripts metadata on PR

on:
  pull_request:
    paths:
      - 'scripts/**'

jobs:
  validate-meta:
    name: Validate meta.yml in changed script dirs
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install pyyaml requests

      - name: Validate meta.yml vs script files and post PR review
        env:
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          echo "Base ref: $BASE_REF"
          git fetch origin "$BASE_REF":refs/remotes/origin/"$BASE_REF" || true

          echo "Gathering changed files"
          DIFF=$(git diff --name-only origin/"$BASE_REF"...HEAD || true)
          echo "$DIFF"

          python3 - <<'PY'
          import os,sys,subprocess,yaml,json
          import requests

          base_ref = os.environ.get('BASE_REF')
          pr_number = os.environ.get('PR_NUMBER')
          token = os.environ.get('GITHUB_TOKEN')
          repo = os.environ.get('GITHUB_REPOSITORY')

          try:
              diff = subprocess.check_output(['git','diff','--name-only',f'origin/{base_ref}...HEAD'], text=True)
          except subprocess.CalledProcessError:
              diff = ''
          changed = [l.strip() for l in diff.splitlines() if l.strip()]

          script_dirs = set()
          for p in changed:
              if p.startswith('scripts/'):
                  parts = p.split('/')
                  if len(parts) >= 2:
                      script_dirs.add(os.path.join(parts[0],parts[1]))

          if not script_dirs:
              print('No changed script directories found. Nothing to validate.')
              sys.exit(0)

          errors = []
          # required meta fields
          required_fields = ['name','description','platforms','files']

          for d in sorted(script_dirs):
              meta_path = os.path.join(d,'meta.yml')
              if not os.path.exists(meta_path):
                  errors.append(f"{d}: missing meta.yml")
                  continue
              try:
                  with open(meta_path,'r') as f:
                      meta = yaml.safe_load(f) or {}
              except Exception as e:
                  errors.append(f"{d}: failed to parse meta.yml: {e}")
                  continue

              # check required fields presence
              missing = [f for f in required_fields if f not in meta]
              if missing:
                  errors.append(f"{d}: meta.yml missing required fields: {missing}")

              name = meta.get('name') or d
              plats = meta.get('platforms') or []
              if isinstance(plats, str):
                  plats = [plats]
              plats = [p.lower() for p in plats]

              files_field = meta.get('files') or []
              if isinstance(files_field, str):
                  files_field = [files_field]

              # check that files listed in meta.yml exist
              for fn in files_field:
                  fn_path = os.path.join(d,fn)
                  if not os.path.exists(fn_path):
                      errors.append(f"{name}: listed file '{fn}' in meta.yml not found in {d}")

              # for platforms, ensure appropriate script types exist
              if any(p in ('mac','linux') for p in plats):
                  ok = False
                  # check files_field for .sh
                  for fn in files_field:
                      if fn.lower().endswith('.sh') and os.path.exists(os.path.join(d,fn)):
                          ok = True
                          break
                  # fallback: any .sh in directory
                  if not ok:
                      for f in os.listdir(d):
                          if f.lower().endswith('.sh') and os.path.isfile(os.path.join(d,f)):
                              ok = True
                              break
                  if not ok:
                      errors.append(f"{name}: platforms {plats} include mac/linux but no .sh file found in {d}")

              if 'windows' in plats:
                  ok = False
                  for fn in files_field:
                      if fn.lower().endswith('.ps1') and os.path.exists(os.path.join(d,fn)):
                          ok = True
                          break
                  if not ok:
                      for f in os.listdir(d):
                          if f.lower().endswith('.ps1') and os.path.isfile(os.path.join(d,f)):
                              ok = True
                              break
                  if not ok:
                      errors.append(f"{name}: platforms {plats} include windows but no .ps1 file found in {d}")

          if errors:
              body = 'Automated validation found issues with scripts in this PR:\n\n'
              for e in errors:
                  body += '- ' + e.replace('\n','\\n') + '\n'

              # post PR review requesting changes
              owner_repo = repo
              url = f'https://api.github.com/repos/{owner_repo}/pulls/{pr_number}/reviews'
              headers = {'Authorization': f'token {token}', 'Accept': 'application/vnd.github.v3+json'}
              payload = {'body': body, 'event': 'REQUEST_CHANGES'}
              r = requests.post(url, headers=headers, json=payload)
              print('Create review response:', r.status_code)
              try:
                  print(r.json())
              except Exception:
                  print(r.text)
              if r.status_code >= 400:
                  print('Failed to post PR review comment')
                  sys.exit(1)

              print('Posted PR review requesting changes')
              sys.exit(1)
          else:
              print('All meta.yml validations passed')
              sys.exit(0)
          PY
