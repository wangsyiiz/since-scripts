name: Validate scripts on PR (comment + checks)

on:
  pull_request:
    paths:
      - 'scripts/**'

jobs:
  validate-meta:
    name: Validate meta.yml in changed script dirs, post PR comment, and run sh/ps1 checks
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install pyyaml requests

      - name: Validate meta.yml vs script files and post PR comment
        env:
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          echo "Base ref: $BASE_REF"
          git fetch origin "$BASE_REF":refs/remotes/origin/"$BASE_REF" || true

          echo "Gathering changed files"
          DIFF=$(git diff --name-only origin/"$BASE_REF"...HEAD || true)
          echo "$DIFF"

          python3 - <<'PY'
          import os,sys,subprocess,yaml,json,requests

          base_ref = os.environ.get('BASE_REF')
          pr_number = os.environ.get('PR_NUMBER')
          token = os.environ.get('GITHUB_TOKEN')
          repo = os.environ.get('GITHUB_REPOSITORY')

          try:
              diff = subprocess.check_output(['git','diff','--name-only',f'origin/{base_ref}...HEAD'], text=True)
          except subprocess.CalledProcessError:
              diff = ''
          changed = [l.strip() for l in diff.splitlines() if l.strip()]

          script_dirs = set()
          for p in changed:
              if p.startswith('scripts/'):
                  parts = p.split('/')
                  if len(parts) >= 2:
                      script_dirs.add(os.path.join(parts[0],parts[1]))

          if not script_dirs:
              print('No changed script directories found. Nothing to validate.')
              sys.exit(0)

          errors = []
          # required meta fields
          required_fields = ['name','description','platforms','files']
          allowed_platforms = {'mac','linux','windows'}

          for d in sorted(script_dirs):
              meta_path = os.path.join(d,'meta.yml')
              if not os.path.exists(meta_path):
                  errors.append(f"{d}: missing meta.yml")
                  continue
              try:
                  with open(meta_path,'r') as f:
                      meta = yaml.safe_load(f) or {}
              except Exception as e:
                  errors.append(f"{d}: failed to parse meta.yml: {e}")
                  continue

              # check required fields presence
              missing = [f for f in required_fields if f not in meta]
              if missing:
                  errors.append(f"{d}: meta.yml missing required fields: {missing}")

              name = meta.get('name') or d
              plats = meta.get('platforms') or []
              if isinstance(plats, str):
                  plats = [plats]
              plats = [p.lower() for p in plats]

              # platforms must only contain allowed values
              bad = [p for p in plats if p not in allowed_platforms]
              if bad:
                  errors.append(f"{name}: platforms contains unsupported values: {bad}; allowed: {sorted(list(allowed_platforms))}")

              files_field = meta.get('files') or []
              if isinstance(files_field, str):
                  files_field = [files_field]

              # check that files listed in meta.yml exist
              for fn in files_field:
                  fn_path = os.path.join(d,fn)
                  if not os.path.exists(fn_path):
                      errors.append(f"{name}: listed file '{fn}' in meta.yml not found in {d}")

              # for platforms, ensure appropriate script types exist
              if any(p in ('mac','linux') for p in plats):
                  ok = False
                  # check files_field for .sh
                  for fn in files_field:
                      if fn.lower().endswith('.sh') and os.path.exists(os.path.join(d,fn)):
                          ok = True
                          break
                  # fallback: any .sh in directory
                  if not ok:
                      for f in os.listdir(d):
                          if f.lower().endswith('.sh') and os.path.isfile(os.path.join(d,f)):
                              ok = True
                              break
                  if not ok:
                      errors.append(f"{name}: platforms {plats} include mac/linux but no .sh file found in {d}")

              if 'windows' in plats:
                  ok = False
                  for fn in files_field:
                      if fn.lower().endswith('.ps1') and os.path.exists(os.path.join(d,fn)):
                          ok = True
                          break
                  if not ok:
                      for f in os.listdir(d):
                          if f.lower().endswith('.ps1') and os.path.isfile(os.path.join(d,f)):
                              ok = True
                              break
                  if not ok:
                      errors.append(f"{name}: platforms {plats} include windows but no .ps1 file found in {d}")

          if errors:
              body = 'Automated validation found issues with scripts in this PR:\n\n'
              for e in errors:
                  body += '- ' + e.replace('\n','\\n') + '\n'

              # post PR comment (issue comment API)
              owner_repo = repo
              url = f'https://api.github.com/repos/{owner_repo}/issues/{pr_number}/comments'
              headers = {'Authorization': f'token {token}', 'Accept': 'application/vnd.github.v3+json'}
              payload = {'body': body}
              r = requests.post(url, headers=headers, json=payload)
              print('Create comment response:', r.status_code)
              try:
                  print(r.json())
              except Exception:
                  print(r.text)
              if r.status_code >= 400:
                  print('Failed to post PR comment')
                  sys.exit(1)

              print('Posted PR comment with validation errors')
              sys.exit(1)
          else:
              print('All meta.yml validations passed')
              sys.exit(0)
          PY

      - name: Run shell & PowerShell static and format checks on changed scripts
        env:
          BASE_REF: ${{ github.event.pull_request.base.ref }}
        run: |
          set -euo pipefail
          echo "Base ref: $BASE_REF"
          git fetch origin "$BASE_REF":refs/remotes/origin/"$BASE_REF" || true

          DIFF=$(git diff --name-only origin/"$BASE_REF"...HEAD || true)
          echo "Changed files:\n$DIFF"

          # collect changed .sh and .ps1 files
          mapfile -t SH_FILES < <(printf "%s\n" "$DIFF" | grep -E '\\.sh$' || true)
          mapfile -t PS1_FILES < <(printf "%s\n" "$DIFF" | grep -E '\\.ps1$' || true)

          if [ ${#SH_FILES[@]} -eq 0 ] && [ ${#PS1_FILES[@]} -eq 0 ]; then
            echo "No .sh or .ps1 files changed in this PR. Skipping shell/ps1 checks."
            exit 0
          fi

          if [ ${#SH_FILES[@]} -gt 0 ]; then
            echo "Shell files to check: ${SH_FILES[*]}"
            sudo apt-get update
            sudo apt-get install -y shellcheck curl

            SHFMT_VER="v3.6.1"
            curl -sL -o /usr/local/bin/shfmt "https://github.com/mvdan/sh/releases/download/${SHFMT_VER}/shfmt_${SHFMT_VER#v}_linux_amd64"
            sudo chmod +x /usr/local/bin/shfmt || true

            # run shfmt (list unformatted files)
            UNFORMATTED=""
            for f in "${SH_FILES[@]}"; do
              if [ -f "$f" ]; then
                out=$(shfmt -l "$f" || true)
                if [ -n "$out" ]; then
                  UNFORMATTED="$UNFORMATTED\n$out"
                fi
              fi
            done

            if [ -n "$(echo -n "$UNFORMATTED" )" ]; then
              echo "shfmt found unformatted files:$UNFORMATTED"
              echo "Run: shfmt -w <file> to fix formatting"
              exit 1
            fi

            # run shellcheck
            echo "Running shellcheck..."
            shellcheck -x ${SH_FILES[*]}
          fi

          if [ ${#PS1_FILES[@]} -gt 0 ]; then
            echo "PowerShell files to check: ${PS1_FILES[*]}"
            # Install PSScriptAnalyzer and run Invoke-ScriptAnalyzer on each file. Fail if any findings with Severity Error/Warning.
            pwsh -NoProfile -Command "Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser -AllowClobber -SkipPublisherCheck"
            PS_FAIL=0
            for f in "${PS1_FILES[@]}"; do
              if [ -f "$f" ]; then
                echo "Analyzing $f"
                pwsh -NoProfile -Command "if ((Invoke-ScriptAnalyzer -Path '$f' -Severity @('Error','Warning')).Count -gt 0) { Write-Output 'ISSUES'; exit 1 } else { exit 0 }" || PS_FAIL=1
              fi
            done
            if [ "$PS_FAIL" -ne 0 ]; then
              echo "PSScriptAnalyzer found issues in one or more .ps1 files"
              exit 1
            fi
          fi
